# src/common/airtable_utils.py
# KRIZZY OPS â€” Airtable Utilities (schema-safe, idempotent-ready)

from __future__ import annotations

import os
import re
import time
import random
from typing import Any, Dict, List, Optional, Tuple, Union

import requests

# ----------------------------
# Config / Env
# ----------------------------

AIRTABLE_API_KEY = os.getenv("AIRTABLE_API_KEY", "").strip()
AIRTABLE_BASE_ID_RAW = os.getenv("AIRTABLE_BASE_ID", "").strip()
AIRTABLE_BASE_ID_ENV_FALLBACK = os.getenv("AIRTABLE_BASE", "").strip()  # optional fallback if you used older name

_DEFAULT_TIMEOUT = 30
_MAX_RETRIES = 6
_BACKOFF_BASE = 1.6
_JITTER = (0.2, 0.9)

_AIRTABLE_V0 = "https://api.airtable.com/v0"
_AIRTABLE_META = "https://api.airtable.com/v0/meta"

BASE_ID_RE = re.compile(r"(app[a-zA-Z0-9]{14})")

# ----------------------------
# Internal helpers
# ----------------------------

def _log(msg: str) -> None:
    print(msg, flush=True)

def normalize_base_id(raw: str) -> str:
    """
    Accepts:
      - appXXXXXXXXXXXXXX
      - https://airtable.com/appXXXXXXXXXXXXXX/...
      - any string containing appXXXXXXXXXXXXXX
    Returns validated base id.
    """
    raw = (raw or "").strip()
    if not raw:
        raise ValueError(
            "AIRTABLE_BASE_ID is empty. Set AIRTABLE_BASE_ID=appXXXXXXXXXXXXXX in Railway."
        )

    m = BASE_ID_RE.search(raw)
    if not m:
        raise ValueError(
            f"Invalid AIRTABLE_BASE_ID value: {raw}. Must contain a base id like appXXXXXXXXXXXXXX."
        )
    return m.group(1)

def get_base_id() -> str:
    raw = AIRTABLE_BASE_ID_RAW or AIRTABLE_BASE_ID_ENV_FALLBACK
    return normalize_base_id(raw)

def airtable_headers() -> Dict[str, str]:
    if not AIRTABLE_API_KEY:
        raise ValueError(
            "AIRTABLE_API_KEY is empty. Set AIRTABLE_API_KEY in Railway environment."
        )
    return {
        "Authorization": f"Bearer {AIRTABLE_API_KEY}",
        "Content-Type": "application/json",
    }

def _request(
    method: str,
    url: str,
    *,
    params: Optional[Dict[str, Any]] = None,
    json_body: Optional[Dict[str, Any]] = None,
    timeout: int = _DEFAULT_TIMEOUT,
    retries: int = _MAX_RETRIES,
) -> requests.Response:
    last_err: Optional[Exception] = None
    for attempt in range(1, retries + 1):
        try:
            resp = requests.request(
                method,
                url,
                headers=airtable_headers(),
                params=params,
                json=json_body,
                timeout=timeout,
            )

            # Success
            if 200 <= resp.status_code < 300:
                return resp

            # Retryable codes
            if resp.status_code in (429, 500, 502, 503, 504):
                sleep_s = (_BACKOFF_BASE ** (attempt - 1)) + random.uniform(*_JITTER)
                _log(f"[AIRTABLE] Retryable {resp.status_code} on {url} (attempt {attempt}/{retries}) sleeping {sleep_s:.2f}s")
                time.sleep(sleep_s)
                continue

            # Non-retryable
            resp.raise_for_status()
            return resp

        except Exception as e:
            last_err = e
            sleep_s = (_BACKOFF_BASE ** (attempt - 1)) + random.uniform(*_JITTER)
            _log(f"[AIRTABLE] Exception on {url} (attempt {attempt}/{retries}): {e} sleeping {sleep_s:.2f}s")
            time.sleep(sleep_s)

    raise RuntimeError(f"Airtable request failed after {retries} attempts: {last_err}")

# ----------------------------
# Public API
# ----------------------------

def v0_url(table_name: str) -> str:
    base_id = get_base_id()
    return f"{_AIRTABLE_V0}/{base_id}/{table_name}"

def meta_tables_url() -> str:
    base_id = get_base_id()
    return f"{_AIRTABLE_META}/bases/{base_id}/tables"

def get_records(
    table_name: str,
    *,
    max_records: int = 100,
    view: Optional[str] = None,
    filter_by_formula: Optional[str] = None,
    fields: Optional[List[str]] = None,
) -> List[Dict[str, Any]]:
    params: Dict[str, Any] = {"maxRecords": max_records}
    if view:
        params["view"] = view
    if filter_by_formula:
        params["filterByFormula"] = filter_by_formula
    if fields:
        # Airtable expects repeated fields[]=Name
        for i, f in enumerate(fields):
            params[f"fields[{i}]"] = f

    url = v0_url(table_name)
    resp = _request("GET", url, params=params)
    data = resp.json()
    return data.get("records", [])

def create_records(
    table_name: str,
    records: List[Dict[str, Any]],
    *,
    typecast: bool = True,
) -> Dict[str, Any]:
    url = v0_url(table_name)
    body = {"records": records, "typecast": typecast}
    resp = _request("POST", url, json_body=body)
    return resp.json()

def update_records(
    table_name: str,
    records: List[Dict[str, Any]],
    *,
    typecast: bool = True,
) -> Dict[str, Any]:
    url = v0_url(table_name)
    body = {"records": records, "typecast": typecast}
    resp = _request("PATCH", url, json_body=body)
    return resp.json()

def delete_records(
    table_name: str,
    record_ids: List[str],
) -> Dict[str, Any]:
    url = v0_url(table_name)
    params = {}
    for i, rid in enumerate(record_ids):
        params[f"records[{i}]"] = rid
    resp = _request("DELETE", url, params=params)
    return resp.json()

def get_base_schema(include_visible_field_ids: bool = True) -> Dict[str, Any]:
    """
    Uses Airtable Meta API to fetch schema even if tables are empty.
    """
    url = meta_tables_url()
    params = {"include": "visibleFieldIds"} if include_visible_field_ids else None
    resp = _request("GET", url, params=params)
    return resp.json()

def table_fields_map() -> Dict[str, List[str]]:
    """
    Returns: { "TableName": ["Field1","Field2",...] }
    """
    schema = get_base_schema()
    out: Dict[str, List[str]] = {}
    for t in schema.get("tables", []):
        name = t.get("name")
        fields = [f.get("name") for f in t.get("fields", []) if f.get("name")]
        if name:
            out[name] = fields
    return out

def validate_table_fields(table_name: str, required_fields: List[str]) -> Tuple[bool, List[str]]:
    fmap = table_fields_map()
    existing = set(fmap.get(table_name, []))
    missing = [f for f in required_fields if f not in existing]
    return (len(missing) == 0, missing)

def safe_airtable_write(
    table_name: str,
    records: List[Dict[str, Any]],
    *,
    mode: str = "create",  # create | update
    idempotency_field: Optional[str] = None,
) -> Dict[str, Any]:
    """
    Safe writer:
      - optional idempotency by skipping records without idempotency_field value
      - retries handled in _request
    """
    if not records:
        return {"records": [], "skipped": 0}

    if idempotency_field:
        filtered = []
        skipped = 0
        for r in records:
            fields = r.get("fields", {})
            if fields.get(idempotency_field) in (None, "", []):
                skipped += 1
                continue
            filtered.append(r)
        records = filtered
    else:
        skipped = 0

    if not records:
        return {"records": [], "skipped": skipped}

    if mode == "update":
        res = update_records(table_name, records)
    else:
        res = create_records(table_name, records)

    res["skipped"] = skipped
    return res
